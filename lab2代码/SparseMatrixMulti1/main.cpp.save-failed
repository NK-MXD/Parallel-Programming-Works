#include<pmmintrin.h>
#include<cstdlib>
#include<algorithm>
#include<windows.h>
#include<iostream>
#include<ctime>
using namespace std;

///要实现的几个函数功能：1.将矩阵转化为COO表示的稀疏矩阵 2.将COO表示的稀疏矩阵转化为矩阵 3.实现非COO表示的矩阵的相乘 4.实现COO表示的稀疏矩阵相乘
///5.实现COO表示的稀疏矩阵的并行乘法
int maxN=1024;
const int T=64;

long long head,tail,freq;


///1.矩阵转化为COO表示的稀疏矩阵
int matrix_to_coo(float **M,int n,float* &value,int* & row,int* & col){
    //n为矩阵行列数 nonzeros代表矩阵的非零元素个数
   int i,j;
   int a=0;
   for(i=0;i<n;i++)
      for(j=0;j<n;j++)
          if(M[i][j]!=0)
              a++;
   value=new float[a];
   col=new int[a];
   row=new int[a];
   int k=0;
   for(i=0;i<n;i++)
   {
      for(j=0;j<n;j++)
      {
          if(M[i][j]!=0)
          {
              row[k]=i;
              col[k]=j;
              value[k++]=M[i][j];
          }
      }
   }
   return a;
}
///2.将COO表示的稀疏矩阵转化为矩阵
void coo_to_matrix(float *value,int *col,int *row,int nonzeros,int n,float** & M){
   M=new float*[n];
   for(int i=0;i<n;i++)
      M[i]=new float[n];
   for(int i=0;i<n;i++)
       for(int j=0;j<n;j++)
           M[i][j]=0;
   for(int i=0;i<nonzeros;i++)
   {
       M[row[i]][col[i]]=value[i];
   }
}

///3.实现COO和向量相乘（串行算法）
void coo_multiply_vector_serial(int nonzeros,int n,int* row,int* col,float* value,float* x,float* y){
    //其中x指的是列向量，这里表示的是稀疏矩阵和列向量相乘
    __m128 t1,t2,sum;
    for(int i=0;i<n;i++)
        y[i]=0;
    for (int i=0;i<nonzeros;i++)
        y[row[i]] += value[i] * x[col[i]];//最后y中得出的结果是最后的稀疏矩阵和列向量相乘的结果

}

///4.实现矩阵和向量相乘（平凡算法）
void matrix_multiply_vector_serial(float **m,int n,float *x,float *y){
   for(int i=0;i<n;i++)
   {
       int y0=0;
       for(int j=0;j<n;j++)
           y0+=m[i][j]*x[j];
       y[i]=y0;
   }
}

///11.实现COO与向量相乘SIMD优化算法SSE1
void coo_multiply_vector_sse1(int nonzeros,int n,int* row,int* col,float* value,float* x,float* y){
    __m128 t1,t2,t3,sum;
    for(int i=0;i<n;i++)
        y[i]=0;

    int choice = nonzeros % 4;
    for (int i=0;i<nonzeros-choice;i+=4){
        //y[row[i]] += value[i] * x[col[i]];
        //这里并行化要如何处理？
        t1 = _mm_set_ps(x[col[i]],x[col[i+1]],x[col[i+2]],x[col[i+3]]);
        sum = _mm_setzero_ps();
        t2 = _mm_set_ps(y[row[i]],y[row[i+1]],y[row[i+2]],y[row[i+3]]);
        t3 = _mm_loadu_ps(value+i);
        sum = _mm_mul_ps(t3,t1);
        t2=_mm_add_ps(t2,sum);
        for(int j=0;j<3;j++)
            y[row[i+j]] = t2.m128_f32[3-j];
    }
    for(int i=nozeros - choice; i < nonzeros ; i++){
        y[row[i]] += value[i] * x[col[i]];
    }

}

///12.实现COO与向量相乘SIMD优化算法SSE2

///5.稀疏矩阵和稠密矩阵相乘SIMD算法优化到最优,a或b的其中一个为稀疏矩阵，一个为稠密矩阵
double matrix_multiply_matrix_sse_title(int n, float**a, float**b,float**c){
    __m128 t1,t2,sum;
    float t;
    long long head,tail,freq;
    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&head);
    for (int i = 0; i < n; ++i) for (int j = 0; j < i; ++j) swap(b[i][j], b[j][i]);
    for (int r = 0; r < n / T; ++r) for (int q = 0; q < n / T; ++q) {
        for (int i = 0; i < T; ++i) for (int j = 0; j < T; ++j) c[r * T + i][q * T + j] = 0.0;
        for (int p = 0; p < n / T; ++p) {
            for (int i = 0; i < T; ++i) for (int j = 0; j < T; ++j) {
                sum = _mm_setzero_ps();
                for (int k = 0; k < T; k += 4){
                    t1 = _mm_loadu_ps(a[r * T + i] + p * T + k);
                    t2 = _mm_loadu_ps(b[q * T + j] + p * T + k);
                    t1 = _mm_mul_ps(t1, t2);
                    sum = _mm_add_ps(sum, t1);
                }
                sum = _mm_hadd_ps(sum, sum);
                sum = _mm_hadd_ps(sum, sum);
                _mm_store_ss(&t, sum);
                c[r * T + i][q * T + j] += t;
            }
        }
    }
    for (int i = 0; i < n; ++i) for (int j = 0; j < i; ++j) swap(b[i][j], b[j][i]);
    QueryPerformanceCounter((LARGE_INTEGER*)&tail);
    cout<<"sse_tile:"<<(double)(tail-head)/(double)freq<<endl;
	return (double)(tail-head)/(double)freq;
}
///9.实现COO与稠密矩阵相乘串行算法
void coo_multiply_matrix_serial(int nonzeros,int n,int* row,int* col,float* value,float**b,float**c){
    for (int i = 0; i < n; ++i) for (int j = 0; j < i; ++j) swap(b[i][j], b[j][i]);
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            c[i][j]=0;

    for (int i=0;i<nonzeros;i++)
        for(int k=0;k<n;k++)
            c[row[i]][k] += value[i] * b[k][col[i]];
    for (int i = 0; i < n; ++i) for (int j = 0; j < i; ++j) swap(b[i][j], b[j][i]);
}


///10.实现COO与稠密矩阵相乘并行算法SEE1
///基本思路是将稠密矩阵进行分块
void coo_multiply_matrix_sse1(int nonzeros,int n,int* row,int* col,float* value,float**b,float**c){
    for (int i = 0; i < n; ++i) for (int j = 0; j < i; ++j) swap(b[i][j], b[j][i]);
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            c[i][j]=0;
    for(int k=0;k<n;k++)
        for (int i=0;i<nonzeros;i++)
            c[row[i]][k] += value[i] * b[k][col[i]];
    for (int i = 0; i < n; ++i) for (int j = 0; j < i; ++j) swap(b[i][j], b[j][i]);
}

///13.实现COO与稠密矩阵相乘并行算法SEE2

///14.实现COO与稠密矩阵相乘并行算法SEE3

///6.生成向量
void generate_vector(int n,float* & x){
    x=new float[n];
    for(int i=0;i<n;i++)
        x[i]=rand()%10+1;
}

///7.生成稠密矩阵
void generate_matrix(float** & m,int n){
   m=new float*[n];
   for(int i=0;i<n;i++)
       m[i]=new float[n];
   for(int i=0;i<n;i++)
   {
       for(int j=0;j<n;j++)
      {
          int x=rand()%10;
          m[i][j]=x+1;
      }
   }
}


///8.生成稀疏矩阵
void generate_sparse_matrix(float** & m,int n,double s){
    //注：s为稀疏度
   m=new float*[n];
   for(int i=0;i<n;i++)
       m[i]=new float[n];
   for(int i=0;i<n;i++)
      for(int j=0;j<n;j++)
      {
          int x=rand()%100000;
          if(x>100000*s)
            m[i][j]=0;
          else
            m[i][j]=x%10+1;
      }
   return;
}

///主函数测试：
int main()
{
    int n=1024;
    srand((int)time(0));
    double s=0.01;
    float **mat=NULL;
    float **mat_recover=NULL;
    float **mat_nonsparse=NULL;
    float **mat_res1=NULL;
    float **mat_res2=NULL;
    float *vec=NULL;
    float *y=NULL;
    float *yy=NULL;
    float *yyy=NULL;
    float *value=NULL;
    int *col=NULL;
    int *row=NULL;
    generate_sparse_matrix(mat,n,s);//生成稀疏矩阵mat
    generate_vector(n,vec);
    generate_vector(n,y);
    generate_vector(n,yy);
    generate_matrix(mat_nonsparse,n);
    generate_matrix(mat_res1,n);
    generate_matrix(mat_res2,n);
    int notzeros=matrix_to_coo(mat,n,value,row,col);//生成对应的COO表示的稀疏矩阵
    //coo_to_matrix(value,col,row,notzeros,n,mat_recover);//将对应的COO表示的稀疏矩阵还原为对应的稀疏矩阵
    /*cout<<"matrix and csr transformation test"<<endl;
    int error=0;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
           if(mat[i][j]!=mat_recover[i][j])
               error=1;
    if(error==1)
        cout<<"test error!"<<endl;
    else
        cout<<"test right!"<<endl;*/

    ///以上为测试转化的过程是否正确
    ///以下为测试稀疏矩阵和向量乘积是否正确
    cout<<"spvm test"<<endl;
    clock_t start,end;
    start=clock();
    matrix_multiply_vector_serial(mat,n,vec,y);
    end=clock();
    printf("time1=%f\n",(double)(end-start)/CLK_TCK);
    start=clock();
    coo_multiply_vector_serial(notzeros,n,row,col,value,vec,yy);
    end=clock();
    printf("time2=%f\n",(double)(end-start)/CLK_TCK);
    start=clock();
    coo_multiply_vector_sse1(notzeros,n,row,col,value,vec,yyy);
    end=clock();
    printf("time2=%f\n",(double)(end-start)/CLK_TCK);
    for(int i=0;i<n;i++)
        if(y[i]!=yy[i])
    {
            cout<<"test error!"<<endl;
            return -1;
    }
    cout<<"test right!"<<endl;
    ///以下为测试稀疏矩阵和矩阵相乘
    /*clock_t start,end;
    start=clock();
    matrix_multiply_matrix_sse_title(n,mat,mat_nonsparse,mat_res1);
    end=clock();
    printf("time1=%f\n",(double)(end-start)/CLK_TCK);
    start=clock();
    coo_multiply_matrix_serial(notzeros,n,row,col,value,mat_nonsparse,mat_res2);
    end=clock();
    printf("time2=%f\n",(double)(end-start)/CLK_TCK);
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            if(mat_res1[i][j]!=mat_res2[i][j])
            {
                cout<<"test error!"<<endl;
                return -1;
            }
    cout<<"test right!"<<endl;*/
    return 0;

}









